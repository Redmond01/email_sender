The backend will majorly consist of server actions.

A. CLIENT PERMISSION AND ACCESS.

<api/signup> (http):
this server will give the user ability to add credentials to the db:
1. collect client data
2. add the data to the database
3. create two tokens using the following process below
a). "acessToken" signed by the JOSE <jwt> method
b). "refreshToken" signed by the JOSE <jwt> method
4. assign the both tokens to the client cookies, via the server cookies method, with some protection from script. 
3. send response and response code back to the client

</login> (http):
this server will be responsible for login:
1. collect client data
2. validate the data with the database
3. collect the client cookies values and do the following:
a). "acessToken" signed by the JOSE <jwt> method
b). "refreshToken" signed by the JOSE <jwt> method
4. send response and response code back to the client


<middleware>(http):
this will be the first line of contact for the server to validate the client, IF client has cookies, it will allow, else it will redirect to "/"
1. protect all the urls IF the following are not (true), and send the client back to the "/" url
a). accessToken not found in client cookies
b). refreshToken not found in client cookies
2. if both "accesstoken" and "refreshToken" are available in the client cookies, do the following
a). call an helper function to validate the client "accessToken", and if true, give client the access to the requested url path
3. if only the refreshToken is available, do the following:
a). redirect the call to ("api/refresh"), and this will do the "refrshToken" validation, and "accessToken" regeneration.

<refreshToken>(http):
this route will only be called by the middleware, when the client is trying to access the protected route, and the client dont have the "accesstoken" credentials
1. this api will be called and given some data, and do the following with the data.
a). calls an helper function that will do validate the data coming from the middleware call "refeshtoken".
b). validate the token, and if true, call a jwt helper function to generarte a new "accessToken".
c). return both the "acessToken" and the receiced "refreshToken", back to the middlware.
2. return a response and response code back to the middlware  (3XX status code resopnse).



B. CLIENT INTERACTIONS API SERVERS

<api/dashboard>(graphql):
this api server will be responsible for data retrival from the db, with the following structure
1. a <useEffect client> call to the graphql server that will return and expose the following data to the client
a) total number of all emails in user db
b) list of emails 
c) list of smpts
d) number of emails sent for the day
e) list of industries 
f). list of schedule times


<api/credentials><http request (POST)>
summary :This api server contains 4 major block, and each of them contribute to the effectivness of the application, and database interactions.
each of them will speak to the database, some of them will either READ, WRITE, while some will be both.

execution: the api will have some dynamic concept to the way they will be effective, which will bring us to the {action, data} types, whereby the action will be
what action will be called, this will be the backbone of what method/function the api call, and the data will be what the logic will work on.

plan: there will be a server called "credential", and this server will be of a POST http request, and it will collect object of the {action, data} request data,
and it will have some switch statement, in which {actions} will be triggred in the switch statment, and the {data} will be passed to the logic that matches switch call.

1. add single credential<POST>:
this logic will recive and do the following:
1. append the argument to the database
2. send response and response code back to the client

2. multiple credential<POST>:
this logic will recive and do the following:
1. append the argument to the database
2. send response and response code back to the client

3. add smtp<POST>:
this logic will recive and do the following:
1. append the argument to the database
2. send response and response code back to the client

4. delete smtp<POST>:
this logic will recive and do the following:
1. delete the argument to the database
2. send response and response code back to the client

4. delete single credential<POST>:
this logic will recive and do the following:
1. delete the argument to the database
2. send response and response code back to the client


<api/scheduler><http request (POST and GET)>
This server will update and add timer details to the database, which will help the application to trigger logic, basically calling emulating the structure of the 
"<api/credentials><http request (POST)>"

1. add scheduler<POST>:
this logic will recive and do the following:
1. append the argument to the database
2. send response and response code back to the client

2. delete scheduler<POST>:
this logic will recive and do the following:
1. delete the argument to the database
2. send response and response code back to the client





C. call execution
This aspect is the main caller action for the application, it will interact with the application database, and make a simple logic call with the following attributes

1. setup a cronjob that will  do the following:
a) call the database <scheduler> model every 1hr.
b). validate the scheduler time, with a preset time and timezone.
2. trigger 

